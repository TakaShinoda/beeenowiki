/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js?!./src/App.vue?vue&type=script&lang=js&":
/*!************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=script&lang=js& ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({});\n\n\n//# sourceURL=webpack:///./src/App.vue?./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js?!./src/pages/From.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib??vue-loader-options!./src/pages/From.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({});\n\n\n//# sourceURL=webpack:///./src/pages/From.vue?./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js?!./src/pages/Home.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib??vue-loader-options!./src/pages/Home.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({});\n\n\n//# sourceURL=webpack:///./src/pages/Home.vue?./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/index.js?!./src/pages/taxIncluded.vue?vue&type=script&lang=js&":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib??vue-loader-options!./src/pages/taxIncluded.vue?vue&type=script&lang=js& ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data() {\n    return { price: 100, tax: 8 };\n  },\n  computed: {\n    taxIncluded: function() {\n      return this.price * (1+ this.tax / 100);\n    }\n  }\n});\n\n\n//# sourceURL=webpack:///./src/pages/taxIncluded.vue?./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/App.vue?vue&type=template&id=7ba5bd90&":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=template&id=7ba5bd90& ***!
  \**********************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    [\n      _c(\"h1\", [_vm._v(\"Beeenowiki\")]),\n      _vm._v(\" \"),\n      _vm._m(0),\n      _vm._v(\" \"),\n      _c(\"router-view\")\n    ],\n    1\n  )\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"p\", [\n      _c(\"img\", {\n        attrs: {\n          src: __webpack_require__(/*! ./img/beeno1.jpg */ \"./src/img/beeno1.jpg\"),\n          alt: \"ビーノのイラスト\",\n          title: \"ナスビーノ\",\n          width: \"300\"\n        }\n      })\n    ])\n  }\n]\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/App.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/pages/From.vue?vue&type=template&id=2d5bb14e&":
/*!*****************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/pages/From.vue?vue&type=template&id=2d5bb14e& ***!
  \*****************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", [\n      _c(\"p\"),\n      _c(\"div\", [_vm._v(\"Beeenoは修羅の国出身です\")]),\n      _c(\"p\")\n    ])\n  }\n]\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/pages/From.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/pages/Home.vue?vue&type=template&id=5a90ec03&":
/*!*****************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/pages/Home.vue?vue&type=template&id=5a90ec03& ***!
  \*****************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    [\n      _c(\"p\"),\n      _c(\"div\", [_vm._v(\"ここはBeeenoの情報をまとめるwikiです。\")]),\n      _c(\"p\"),\n      _vm._v(\" \"),\n      _c(\"router-link\", { attrs: { to: \"/about\" } }, [\n        _vm._v(\"Go to About page.\")\n      ])\n    ],\n    1\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/pages/Home.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/pages/taxIncluded.vue?vue&type=template&id=a903919a&":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/pages/taxIncluded.vue?vue&type=template&id=a903919a& ***!
  \************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", [\n    _c(\"div\", [\n      _c(\"input\", {\n        directives: [\n          {\n            name: \"model\",\n            rawName: \"v-model.number\",\n            value: _vm.price,\n            expression: \"price\",\n            modifiers: { number: true }\n          }\n        ],\n        attrs: { type: \"number\" },\n        domProps: { value: _vm.price },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.price = _vm._n($event.target.value)\n          },\n          blur: function($event) {\n            return _vm.$forceUpdate()\n          }\n        }\n      }),\n      _vm._v(\"円\\n    \"),\n      _c(\"p\", [_vm._v(\"消費税込みの金額 \" + _vm._s(_vm.taxIncluded) + \" 円\")])\n    ]),\n    _vm._v(\" \"),\n    _c(\"div\", [\n      _c(\"input\", {\n        directives: [\n          {\n            name: \"model\",\n            rawName: \"v-model.number\",\n            value: _vm.tax,\n            expression: \"tax\",\n            modifiers: { number: true }\n          }\n        ],\n        attrs: { type: \"number\" },\n        domProps: { value: _vm.tax },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.tax = _vm._n($event.target.value)\n          },\n          blur: function($event) {\n            return _vm.$forceUpdate()\n          }\n        }\n      }),\n      _vm._v(\"\\n    %\\n  \")\n    ])\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n\n//# sourceURL=webpack:///./src/pages/taxIncluded.vue?./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js?");

/***/ }),

/***/ "./node_modules/vue-router/dist/vue-router.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/vue-router/dist/vue-router.esm.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*!\n  * vue-router v3.0.6\n  * (c) 2019 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if ( true && !condition) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n  }\n}\n\nfunction isError (err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1\n}\n\nfunction extend (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\nvar View = {\n  name: 'RouterView',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    // used by devtools to display a router-view badge\n    data.routerView = true;\n\n    // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent && parent._routerRoot !== parent) {\n      var vnodeData = parent.$vnode && parent.$vnode.data;\n      if (vnodeData) {\n        if (vnodeData.routerView) {\n          depth++;\n        }\n        if (vnodeData.keepAlive && parent._inactive) {\n          inactive = true;\n        }\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h()\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n      if (\n        (val && current !== vm) ||\n        (!val && current === vm)\n      ) {\n        matched.instances[name] = val;\n      }\n    }\n\n    // also register instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    };\n\n    // register instance in init hook\n    // in case kept-alive component be actived when routes changed\n    data.hook.init = function (vnode) {\n      if (vnode.data.keepAlive &&\n        vnode.componentInstance &&\n        vnode.componentInstance !== matched.instances[name]\n      ) {\n        matched.instances[name] = vnode.componentInstance;\n      }\n    };\n\n    // resolve props\n    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);\n    if (propsToPass) {\n      // clone to prevent mutation\n      propsToPass = data.props = extend({}, propsToPass);\n      // pass non-declared props as attrs\n      var attrs = data.attrs = data.attrs || {};\n      for (var key in propsToPass) {\n        if (!component.props || !(key in component.props)) {\n          attrs[key] = propsToPass[key];\n          delete propsToPass[key];\n        }\n      }\n    }\n\n    return h(component, data, children)\n  }\n}\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      if (true) {\n        warn(\n          false,\n          \"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", \" +\n          \"expecting an object, function or boolean.\"\n        );\n      }\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n  .replace(encodeReserveRE, encodeReserveReplacer)\n  .replace(commaRE, ','); };\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery (\n  query,\n  extraQuery,\n  _parseQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n     true && warn(false, e.message);\n    parsedQuery = {};\n  }\n  for (var key in extraQuery) {\n    parsedQuery[key] = extraQuery[key];\n  }\n  return parsedQuery\n}\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom,\n  router\n) {\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\n\n  var query = location.query || {};\n  try {\n    query = clone(query);\n  } catch (e) {}\n\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery$$1),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n  }\n  return Object.freeze(route)\n}\n\nfunction clone (value) {\n  if (Array.isArray(value)) {\n    return value.map(clone)\n  } else if (value && typeof value === 'object') {\n    var res = {};\n    for (var key in value) {\n      res[key] = clone(value[key]);\n    }\n    return res\n  } else {\n    return value\n  }\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (\n  ref,\n  _stringifyQuery\n) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash\n}\n\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  // handle null value #1566\n  if (!a || !b) { return a === b }\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) {\n    var aVal = a[key];\n    var bVal = b[key];\n    // check nested equality\n    if (typeof aVal === 'object' && typeof bVal === 'object') {\n      return isObjectEqual(aVal, bVal)\n    }\n    return String(aVal) === String(bVal)\n  })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'RouterLink',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass;\n    // Support global empty active class\n    var activeClassFallback = globalActiveClass == null\n      ? 'router-link-active'\n      : globalActiveClass;\n    var exactActiveClassFallback = globalExactActiveClass == null\n      ? 'router-link-exact-active'\n      : globalExactActiveClass;\n    var activeClass = this.activeClass == null\n      ? activeClassFallback\n      : this.activeClass;\n    var exactActiveClass = this.exactActiveClass == null\n      ? exactActiveClassFallback\n      : this.exactActiveClass;\n    var compareTarget = location.path\n      ? createRoute(null, location, null, router)\n      : route;\n\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\n    classes[activeClass] = this.exact\n      ? classes[exactActiveClass]\n      : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler; });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n}\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install (Vue) {\n  if (install.installed && _Vue === Vue) { return }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  var isDef = function (v) { return v !== undefined; };\n\n  var registerInstance = function (vm, callVal) {\n    var i = vm.$options._parentVnode;\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\n      }\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed () {\n      registerInstance(this);\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this._routerRoot._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this._routerRoot._route }\n  });\n\n  Vue.component('RouterView', View);\n  Vue.component('RouterLink', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  var firstChar = relative.charAt(0);\n  if (firstChar === '/') {\n    return relative\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\nvar isarray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\n// $flow-disable-line\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  params = params || {};\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = pathToRegexp_1.compile(path));\n\n    // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}\n    if (params.pathMatch) { params[0] = params.pathMatch; }\n\n    return filler(params, { pretty: true })\n  } catch (e) {\n    if (true) {\n      warn(false, (\"missing param for \" + routeMsg + \": \" + (e.message)));\n    }\n    return ''\n  } finally {\n    // delete the 0 if it was added\n    delete params[0];\n  }\n}\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathList,\n  oldPathMap,\n  oldNameMap\n) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || [];\n  // $flow-disable-line\n  var pathMap = oldPathMap || Object.create(null);\n  // $flow-disable-line\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route);\n  });\n\n  // ensure wildcard routes are always at the end\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathList,\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (true) {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(path || name)) + \" cannot be a \" +\n      \"string id. Use an actual component instead.\"\n    );\n  }\n\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\n  var normalizedPath = normalizePath(\n    path,\n    parent,\n    pathToRegexpOptions.strict\n  );\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (true) {\n      if (route.name && !route.redirect && route.children.some(function (child) { return /^\\/?$/.test(child.path); })) {\n        warn(\n          false,\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n          \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'\\\"), \" +\n          \"the default child route will not be rendered. Remove the name from \" +\n          \"this route and use the name of the default child route for named \" +\n          \"links instead.\"\n        );\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias)\n      ? route.alias\n      : [route.alias];\n\n    aliases.forEach(function (alias) {\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        aliasRoute,\n        parent,\n        record.path || '/' // matchAs\n      );\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if ( true && !matchAs) {\n      warn(\n        false,\n        \"Duplicate named routes definition: \" +\n        \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n      );\n    }\n  }\n}\n\nfunction compileRouteRegex (path, pathToRegexpOptions) {\n  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\n  if (true) {\n    var keys = Object.create(null);\n    regex.keys.forEach(function (key) {\n      warn(!keys[key.name], (\"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\"));\n      keys[key.name] = true;\n    });\n  }\n  return regex\n}\n\nfunction normalizePath (path, parent, strict) {\n  if (!strict) { path = path.replace(/\\/$/, ''); }\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\n/*  */\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append,\n  router\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next._normalized) {\n    return next\n  } else if (next.name) {\n    return extend({}, raw)\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = extend({}, next);\n    next._normalized = true;\n    var params = extend(extend({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n    } else if (true) {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : basePath;\n\n  var query = resolveQuery(\n    parsedPath.query,\n    next.query,\n    router && router.options.parseQuery\n  );\n\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\n/*  */\n\n\n\nfunction createMatcher (\n  routes,\n  router\n) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (true) {\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n      }\n      if (!record) { return _createRoute(null, location) }\n      var paramNames = record.regex.keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n      ? originalRedirect(createRoute(record, location, null, router))\n      : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      if (true) {\n        warn(\n          false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n        );\n      }\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (true) {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      if (true) {\n        warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n      }\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom, router)\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  regex,\n  path,\n  params\n) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) {\n      // Fix #1994: using * with props: true generates a param named 0\n      params[key.name || 'pathMatch'] = val;\n    }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  // Fix for #1585 for Firefox\n  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678\n  window.history.replaceState({ key: getStateKey() }, '', window.location.href.replace(window.location.origin, ''));\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (true) {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior.call(router, to, from, isPop ? position : null);\n\n    if (!shouldScroll) {\n      return\n    }\n\n    if (typeof shouldScroll.then === 'function') {\n      shouldScroll.then(function (shouldScroll) {\n        scrollToPosition((shouldScroll), position);\n      }).catch(function (err) {\n        if (true) {\n          assert(false, err.toString());\n        }\n      });\n    } else {\n      scrollToPosition(shouldScroll, position);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction normalizeOffset (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\nfunction scrollToPosition (shouldScroll, position) {\n  var isObject = typeof shouldScroll === 'object';\n  if (isObject && typeof shouldScroll.selector === 'string') {\n    var el = document.querySelector(shouldScroll.selector);\n    if (el) {\n      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};\n      offset = normalizeOffset(offset);\n      position = getElementPosition(el, offset);\n    } else if (isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n  } else if (isObject && isValidPosition(shouldScroll)) {\n    position = normalizePosition(shouldScroll);\n  }\n\n  if (position) {\n    window.scrollTo(position.x, position.y);\n  }\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && (function () {\n  var ua = window.navigator.userAgent;\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now\n  ? window.performance\n  : Date;\n\nvar _key = genKey();\n\nfunction genKey () {\n  return Time.now().toFixed(3)\n}\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  _key = key;\n}\n\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\nfunction resolveAsyncComponents (matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n\n        var resolve = once(function (resolvedDef) {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default;\n          }\n          // save resolved on async factory in case it's used elsewhere\n          def.resolved = typeof resolvedDef === 'function'\n            ? resolvedDef\n            : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n          if (pending <= 0) {\n            next();\n          }\n        });\n\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n           true && warn(false, msg);\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg);\n            next(error);\n          }\n        });\n\n        var res;\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) { next(); }\n  }\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\nvar hasSymbol =\n  typeof Symbol === 'function' &&\n  typeof Symbol.toStringTag === 'symbol';\n\nfunction isESModule (obj) {\n  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    if (called) { return }\n    called = true;\n    return fn.apply(this, args)\n  }\n}\n\n/*  */\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError (errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) { cb(route); });\n    }\n  }, function (err) {\n    if (onAbort) {\n      onAbort(err);\n    }\n    if (err && !this$1.ready) {\n      this$1.ready = true;\n      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });\n    }\n  });\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  var abort = function (err) {\n    if (isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) { cb(err); });\n      } else {\n        warn(false, 'uncaught error during route navigation:');\n        console.error(err);\n      }\n    }\n    onAbort && onAbort(err);\n  };\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL();\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  this.pending = route;\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    try {\n      hook(route, current, function (to) {\n        if (to === false || isError(to)) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (\n          typeof to === 'string' ||\n          (typeof to === 'object' && (\n            typeof to.path === 'string' ||\n            typeof to.name === 'string'\n          ))\n        ) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort();\n          if (typeof to === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function () { return this$1.current === route; };\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { cb(); });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\n      // strip full URL origin\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}\n\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (\n    instances[key] &&\n    !instances[key]._isBeingDestroyed // do not reuse being destroyed instance\n  ) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\n/*  */\n\nvar HTML5History = /*@__PURE__*/(function (History$$1) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      setupScroll();\n    }\n\n    var initLocation = getLocation(this.base);\n    window.addEventListener('popstate', function (e) {\n      var current = this$1.current;\n\n      // Avoiding first `popstate` event dispatched in some browsers but first\n      // history route not updated since async guard at the same time.\n      var location = getLocation(this$1.base);\n      if (this$1.current === START && location === initLocation) {\n        return\n      }\n\n      this$1.transitionTo(location, function (route) {\n        if (supportsScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    });\n  }\n\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = decodeURI(window.location.pathname);\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\nvar HashHistory = /*@__PURE__*/(function (History$$1) {\n  function HashHistory (router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    var router = this.router;\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {\n      var current = this$1.current;\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        if (supportsScroll) {\n          handleScroll(this$1.router, route, current, true);\n        }\n        if (!supportsPushState) {\n          replaceHash(route.fullPath);\n        }\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(\n      cleanPath(base + '/#' + location)\n    );\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  // empty path\n  if (index < 0) { return '' }\n\n  href = href.slice(index + 1);\n  // decode the hash but not the search or hash\n  // as search(query) is already decoded\n  // https://github.com/vuejs/vue-router/issues/2708\n  var searchIndex = href.indexOf('?');\n  if (searchIndex < 0) {\n    var hashIndex = href.indexOf('#');\n    if (hashIndex > -1) { href = decodeURI(href.slice(0, hashIndex)) + href.slice(hashIndex); }\n    else { href = decodeURI(href); }\n  } else {\n    if (searchIndex > -1) { href = decodeURI(href.slice(0, searchIndex)) + href.slice(searchIndex); }\n  }\n\n  return href\n}\n\nfunction getUrl (path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  return (base + \"#\" + path)\n}\n\nfunction pushHash (path) {\n  if (supportsPushState) {\n    pushState(getUrl(path));\n  } else {\n    window.location.hash = path;\n  }\n}\n\nfunction replaceHash (path) {\n  if (supportsPushState) {\n    replaceState(getUrl(path));\n  } else {\n    window.location.replace(getUrl(path));\n  }\n}\n\n/*  */\n\nvar AbstractHistory = /*@__PURE__*/(function (History$$1) {\n  function AbstractHistory (router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\n\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (true) {\n        assert(false, (\"invalid mode: \" + mode));\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: { configurable: true } };\n\nVueRouter.prototype.match = function match (\n  raw,\n  current,\n  redirectedFrom\n) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n   true && assert(\n    install.installed,\n    \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n    \"before creating root instance.\"\n  );\n\n  this.apps.push(app);\n\n  // set up app destroyed handler\n  // https://github.com/vuejs/vue-router/issues/2639\n  app.$once('hook:destroyed', function () {\n    // clean out app from this.apps array once destroyed\n    var index = this$1.apps.indexOf(app);\n    if (index > -1) { this$1.apps.splice(index, 1); }\n    // ensure we still have a main app or null if no apps\n    // we do not release the router so it can be reused\n    if (this$1.app === app) { this$1.app = this$1.apps[0] || null; }\n  });\n\n  // main app previously initialized\n  // return as we don't need to set up new history listener\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  return registerHook(this.beforeHooks, fn)\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve (fn) {\n  return registerHook(this.resolveHooks, fn)\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  return registerHook(this.afterHooks, fn)\n};\n\nVueRouter.prototype.onReady = function onReady (cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError (errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? to.matched\n      ? to\n      : this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  current = current || this.history.current;\n  var location = normalizeLocation(\n    to,\n    current,\n    append,\n    this\n  );\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction registerHook (list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n    if (i > -1) { list.splice(i, 1); }\n  }\n}\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install;\nVueRouter.version = '3.0.6';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VueRouter);\n\n\n//# sourceURL=webpack:///./node_modules/vue-router/dist/vue-router.esm.js?");

/***/ }),

/***/ "./node_modules/vue/dist/vue.runtime.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.runtime.esm.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"development\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"development\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (true) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if ( true && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) { return a.id - b.id; });\n  }\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if ( true && customSetter) {\n        customSetter();\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if ( true &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     true && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if ( true &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     true && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (true) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n       true && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n     true && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (true) {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && \"development\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (true) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (true) {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (true) {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (true) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if ( true && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    true\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if ( true && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (true) {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (true) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\n      \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n      'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n      'prevent conflicts with Vue internals' +\n      'See: https://vuejs.org/v2/api/#data',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) ||\n        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n      if (!has && !isAllowed) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\nvar mark;\nvar measure;\n\nif (true) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      // perf.clearMeasures(name)\n    };\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n       true && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (true) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (true) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {}\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (true) {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if ( true && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n       true && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n       true && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if ( true && key !== '' && key !== null) {\n      // null is a speical value for explicitly removing a binding\n      warn(\n        (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n        this\n      );\n    }\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (true) {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (true) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n     true && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if ( true &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (true) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {}\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack becaues all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if ( true && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if ( true && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n       true && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                 true\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : undefined\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (true) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (true) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if ( true && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (true) {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (true) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (true) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if ( true && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if ( true && !config.async) {\n        flushSchedulerQueue();\n        return\n      }\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  true\n    ? expOrFn.toString()\n    : undefined;\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n       true && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (true) {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {}\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n     true && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (true) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n       true && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if ( true && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (true) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if ( true &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (true) {\n      if (typeof methods[key] !== 'function') {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (true) {\n    dataDef.set = function () {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if ( true && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (true) {\n      initProxy(vm);\n    } else {}\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if ( true && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if ( true &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if ( true && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if ( true && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (true) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.10';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n       true && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (true) {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if ( true && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (true) {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (true) {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (true) {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (true) {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if ( true &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if ( true &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (true) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if ( true && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if ( true && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n     true && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if ( true && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if ( true &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (true) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        true\n      ) {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if ( true &&\n      config.productionTip !== false &&\n      typeof console !== 'undefined'\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vue);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/vue/dist/vue.runtime.esm.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/App.vue":
/*!*********************!*\
  !*** ./src/App.vue ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=7ba5bd90& */ \"./src/App.vue?vue&type=template&id=7ba5bd90&\");\n/* harmony import */ var _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=js& */ \"./src/App.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/App.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/App.vue?");

/***/ }),

/***/ "./src/App.vue?vue&type=script&lang=js&":
/*!**********************************************!*\
  !*** ./src/App.vue?vue&type=script&lang=js& ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/vue-loader/lib??vue-loader-options!./App.vue?vue&type=script&lang=js& */ \"./node_modules/vue-loader/lib/index.js?!./src/App.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/App.vue?");

/***/ }),

/***/ "./src/App.vue?vue&type=template&id=7ba5bd90&":
/*!****************************************************!*\
  !*** ./src/App.vue?vue&type=template&id=7ba5bd90& ***!
  \****************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../node_modules/vue-loader/lib??vue-loader-options!./App.vue?vue&type=template&id=7ba5bd90& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/App.vue?vue&type=template&id=7ba5bd90&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_7ba5bd90___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/App.vue?");

/***/ }),

/***/ "./src/img/beeno1.jpg":
/*!****************************!*\
  !*** ./src/img/beeno1.jpg ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQECWAJYAAD/4TXGRXhpZgAATU0AKgAAAAgABgALAAIAAAAmAAAIYgESAAMAAAABAAEAAAExAAIAAAAmAAAIiAEyAAIAAAAUAAAIrodpAAQAAAABAAAIwuocAAcAAAgMAAAAVgAAEUYc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFdpbmRvd3MgUGhvdG8gRWRpdG9yIDEwLjAuMTAwMTEuMTYzODQAV2luZG93cyBQaG90byBFZGl0b3IgMTAuMC4xMDAxMS4xNjM4NAAyMDE5OjA0OjE4IDIxOjE5OjQzAAAGkAMAAgAAABQAABEckAQAAgAAABQAABEwkpEAAgAAAAMwMAAAkpIAAgAAAAMwMAAAoAEAAwAAAAEAAQAA6hwABwAACAwAAAkQAAAAABzqAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAxODoxMDoxMCAwMzowNjoxOAAyMDE4OjEwOjEwIDAzOjA2OjE4AAAAAAYBAwADAAAAAQAGAAABGgAFAAAAAQAAEZQBGwAFAAAAAQAAEZwBKAADAAAAAQAC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IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMAAwICAwICAwMDAwQDAwQFCAUFBAQFCgcHBggMCgwMCwoLCw0OEhANDhEOCwsQFhARExQVFRUMDxcYFhQYEhQVFP/bAEMBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIBNcEBQMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AOtooor+JD+0wooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooqSGGS4kWOKNpZG6KgJJ79KqMZTkoxV2zOpUhRhKpUklFK7b0SS3bfRIjoroNN8E394QZ8WkRAOX5bkf3R/XHWuhtPA2nQYMxluTtwQzbVz6gDn9a/Qcs4Dz7M4qoqPs4vrP3fw1l8+XXofg3EnjlwPw3UlQni/rFRfZor2n/k91Tv3XPddUjz6ivSv+EP0j/n0/8AIj/41SvvAdnMS1tLJakn7p+dQMds8/rXs4jwwz2jT56bp1H2jJ3/APJoxX4nx+X/AElOCMZXVKvGvQj/ADTpxcf/ACnOpL/yU4KitDVdDu9Gk23EeUOMSpkoc9s468Hj2rPr8uxWFr4GtLD4mDhOO6asz+mcszTA5zhIY7Lq0atKaupRd0/+D3W62YUUUVyHqBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUVc0zSLrWJjHbR7tuNzE4VQT1J/yeDXbab4JsLNQ0+byUEHL8Lwf7o/DrnpX22Q8H5rxD+8w0OWn/ADy0j8tG38lZdWj8a458WeGOAX7DMarqYj/n1TtKfTWV2owWqfvNNrWKlY4GGGS4kWOKNpZG6KgJJ/Ctuw8F6jebWlVbWM4OZD82D6Adx6HFegwwx28YjijWKNeioAAPwp9fs2W+FeBotTzCvKo+0Vyr0e7fqnE/j/iL6T2d4xSpZDg4YdfzTftJ77pWjCLatdNTS11ejXN2PgWwtwDcNJdPjBydi9eoA5/Wt+3tYbRCkEUcKE5KxqFGfXipaK/VsuyTLcpjy4GhGHmlr85PV/Nn8ucQcZ8RcVT586xtSsr35XL3E32grQj8orp2CiiivcPjAooooAiubaK8t3hmQSROMMprzjxD4fl0O4yMyWrn5JP/AGU+/wDP+XplV7+xi1KzltpgTHIMHacEc5BH418HxZwrh+JMK7LlrwT5Jf8Atr/uv8N11T/cfCvxOx3h3miu3PBVWva0/Lbnguk4r5TS5X0cfJKKnvLSSxupbeUYkjbaeuD7j2NQV/GVSnOjOVOorSi7Ndmtz/YLD4ili6MMRQkpQmlKLWzTV015NBRRRWR0BRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFW9L02XVb6O3iB+Y/MwGdi92P0qpXeeBdNWDT2vGwZJyQp9FBxjp3IP5CvseE8j/1gzWnhJfAven/AIV/m2l87n5J4pca/wCofDFfNaVvbSap0k9V7SV7N+UUpSt15bdTe07ToNLtVt7ddqLySerH1PvVmiiv7Wo0aeHpxo0YqMYqyS0SSP8AGvGYzEZhiKmLxdRzqTblKUndtvVtt7thRRXnfxK/aE+HvwlDp4m8T2dneKM/YImM10eMgeUgLDPYsAOetaykoq8nYnDYTEY2oqOGpucn0im39yPRKK+EPiP/AMFNEDSW3gPwoZDnCX+uPgH1xBGfyJf8K8U1fxH+0F+0WpF7ear/AGPMP9VkafYsuf7o2iQD1wxry8RmeGw8eactPuX3s/U8u8M84xMVVx8o4eH953l/4CvybTP0F+I37UXwx+F3nR6z4rs5L+PIOn6e32q43D+Eqmdh/wB8rXzZ4w/4KeWcdxLD4V8EzXMWf3d1q12IyfrEgb/0OvLfCP7Eq/JL4n8QFjn5rbS0/wDajj/2WvbPB/wL8E+B2jl0zQbdrtAMXd3meXI/iBbO0/7oFfF4zjChTuqPvPy/zf6I/QcJwXwvlq/f82Jn5txj9ys/xkVPBP8AwUD1u01LTZ/iP4JPh/w1qO5YNVso5chhjB2P99eeSOe4B6V9j+G/Eml+L9Ds9Z0W+h1LS7yPzYLq3bcjr7H1ByCDyCCDyK+XfH/gPTviL4VvdD1JB5U65jl25aGQD5ZF9wfzGR3rxv8AYb+LGofCL4taj8K/EkxisNSuWht1kb5YL5eF29sSgbeOp8v3r0Mh4h/tO9OqrSX5dP8AI8LiLg7A4zAVcwyin7OpSV5QTbUo9Wr6ppb9Hba7P0Yooor7o/n447x5pP8Aq9QjX/pnLgf98sePwyf9muNr128tI761lt5RmORdp6ZHuPcV5PdW7WtzLA5BeNyhK9Mg4r+VfEvI1gMxjmFJe5W38prf71Z+tz/T/wCjjxpLPOH55BipXq4O3L50pX5f/AHePlHlIqKKK/Gz+vAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvVdDRY9FsQqhR5KHAGOSASfzryqvUfDdx9q0KyfbtxHsxnP3flz+lfuPhROCzHEQfxOF16KSv+aP4r+lJRrS4ey+tH+GqzT16uEnHT0jLXp89dKiiiv6dP82D4r/au+P3j2++LH/Cn/AlxFoE8kMbT6p53lzylo/NKo/8AyzULj7vzEggHsfI/C/7Fcclx9q8WeI5buViWkh09cbj6mV8k/wDfI+tXv25pH+Hv7V3h3xPF8wlsrO+YdM+XK8bL+Kxj86+lIJI7iGOaJleKRQ6OpyGBGQRX5JxVmONwldRpztF3/D/gNH9cZG4ZXkeDnl8VBVYJyaWrl9q73327dDi/B/wb8HeB/LbSNAtYbhMYupV82bI7h3yR+GK7Tyx3qSjbX5dUrVK0uapJt+eoqladWXNOTb8xm3jGKNtSbaTA9M1iZXI8V8m/tieCJtD17R/Hmll7eV3SC4miOCk6fNFJnscKR/wAetfW2Paua+JHgmD4g+B9X0GcKPtcBEUjf8s5RzG34MB+Ga9bK8Z9RxUKvTZ+j/q/yPQy7F/VMTGo/h2fo9z2f9nn4tQfGr4S6H4mVkF9JH9n1CJP+Wd0mBIMdgeGA/uutekV+bn/AAT3+KM/gD4rap8PtYdra11oskUUxwIr6LPy8njcodfUsqCv0jr+kcNW9tSUj+deMsj/ALAzirhoL93L3of4ZdPk7r5BXDePNNEN5FeIDiYbX4ONwxjn3Hb/AGa7ms/XtOGqaVcQbd0m3dH0zuHTk9PT6E18xxdk/wDbmT1sNFXmvej/AIo9vVXj8z6Xwp4tfBfFuEzGpK1GT9nV1svZz0bflF8s/WKPLKKKK/iM/wBngooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACu2+H94rW11anAdX80c8kEYPHtgfnXE1ueDbv7Lr0SkqFmVoyW/MY98gD8a+44Kx/9nZ9hqjeknyP/t7T82n8j8W8ZMiWf8DZjQSvOnD2sfWl779bxUlbz01sej0UUV/ax/jafD3/AAU88GG48P8AgzxXFEP9FuZtNuJB1IkUSRg+wMcn/fVaf7O/igeLvg/4cumcPPbwfYpgOoaI7Bn3KhT+Ne1ftf8Agf8A4T79nfxhZpGr3Vna/wBpQFuqtARI2Pcorr/wKvjH9hnxbuXxH4YlcnGzUbdO3aOU/wDoqvzTjLC+0w7qr7Nn+j/zP6e4NxP9ocKeyfxYebX/AG7LX85P7j6sxRjNPxRt9ua/FjvuM2ijAp+00baBXI/oKMGpNtJtoJufEf7UXhu8+GPxi07xfozNZtfSJqEE8fHl3cTAsR752P8AVjX6b/C3x7afFD4d+H/FVltEOqWiTtGpJEcnSSPP+y4Zf+A18h/tUeB/+Ew+EuoTxR773SCNQhwvO1QRIM+mwsfqoqz/AMEz/iYdQ8OeJPAl1LmXT5BqdkpyT5MhCSqOwCuEP1lNfuXCeP8ArGGjCT1Wn3bfgebxxgVm/DtPMIq9TDOz/wADsvwfL+J9uUUUV+hH8znmXijTxpuszIibIn/eIOMYPXGOgByPwrJruPH1j5lrb3arzG2xyF/hPQk+gI/8erh6/ibjLK/7IzuvQirQk+aPpLXTyTuvkf7MeEXEz4q4MwONqS5qsI+znvfmp+7d36yjyzf+Lpsiiiivij9jCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAp8Mz28ySxnbIjBlOM4IORTKKuMpQkpRdmjOpThWhKnUinFqzT1TT3TXVM9etbhbq2inQEJIgcBuuCM1LXPeB7xbjRRCMB4HZSN2SQTuBx26kfhXQ1/eOS5gs0y6hjV9uKb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vpG0V6e7Zv5tn7/kXg9wPw9KNTC5dCc4681S9R3XX320n25Urb7jpHaR2d2LOxyWJySfWm0UV8U25O7P2OMYwioxVkgooopFBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBd/trUP+f8Auf8Av83+NH9tah/z/wBz/wB/m/xqlRXo/wBpY3/n/P8A8Cf+Z8//AKvZN/0B0v8AwXD/ACNePxbq0aKouzhRgbkUn8yOad/wmGr/APP3/wCQ0/wrGor0FxFnUVZY2r/4Mn/meDLw/wCD5ycpZPhm3/04pf8AyBs/8Jhq/wDz9/8AkNP8KP8AhMNX/wCfv/yGn+FY1FP/AFjzr/oNq/8Agyf+ZP8AxD3g3/oTYb/wRS/+QNn/AITDV/8An7/8hp/hR/wmGr/8/f8A5DT/AArGoo/1jzr/AKDav/gyf+Yf8Q94N/6E2G/8EUv/AJA2f+Ew1f8A5+//ACGn+FH/AAmGr/8AP3/5DT/Csaij/WPOv+g2r/4Mn/mH/EPeDf8AoTYb/wAEUv8A5A0Jtf1KeQu19OGP9xyo/IcVXuNQurtAk9zNMgOQskhYZ9eTVeivNq5hjK/N7atKV97ybv63ep9FhcgyjAuDwuDp0+S3LywjHltorWStbpYKKKK8894KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//2Q==\"\n\n//# sourceURL=webpack:///./src/img/beeno1.jpg?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n/* harmony import */ var _App_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue */ \"./src/App.vue\");\n/* harmony import */ var _router_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./router/index.js */ \"./src/router/index.js\");\n\n\n\n\nnew vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n  el: '#app',\n  router: _router_index_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  render: h => h(_App_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n})\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/pages/From.vue":
/*!****************************!*\
  !*** ./src/pages/From.vue ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _From_vue_vue_type_template_id_2d5bb14e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./From.vue?vue&type=template&id=2d5bb14e& */ \"./src/pages/From.vue?vue&type=template&id=2d5bb14e&\");\n/* harmony import */ var _From_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./From.vue?vue&type=script&lang=js& */ \"./src/pages/From.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _From_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _From_vue_vue_type_template_id_2d5bb14e___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _From_vue_vue_type_template_id_2d5bb14e___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/pages/From.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/pages/From.vue?");

/***/ }),

/***/ "./src/pages/From.vue?vue&type=script&lang=js&":
/*!*****************************************************!*\
  !*** ./src/pages/From.vue?vue&type=script&lang=js& ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_index_js_vue_loader_options_From_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib??vue-loader-options!./From.vue?vue&type=script&lang=js& */ \"./node_modules/vue-loader/lib/index.js?!./src/pages/From.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_vue_loader_lib_index_js_vue_loader_options_From_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/pages/From.vue?");

/***/ }),

/***/ "./src/pages/From.vue?vue&type=template&id=2d5bb14e&":
/*!***********************************************************!*\
  !*** ./src/pages/From.vue?vue&type=template&id=2d5bb14e& ***!
  \***********************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_From_vue_vue_type_template_id_2d5bb14e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib??vue-loader-options!./From.vue?vue&type=template&id=2d5bb14e& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/pages/From.vue?vue&type=template&id=2d5bb14e&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_From_vue_vue_type_template_id_2d5bb14e___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_From_vue_vue_type_template_id_2d5bb14e___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/pages/From.vue?");

/***/ }),

/***/ "./src/pages/Home.vue":
/*!****************************!*\
  !*** ./src/pages/Home.vue ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Home_vue_vue_type_template_id_5a90ec03___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Home.vue?vue&type=template&id=5a90ec03& */ \"./src/pages/Home.vue?vue&type=template&id=5a90ec03&\");\n/* harmony import */ var _Home_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Home.vue?vue&type=script&lang=js& */ \"./src/pages/Home.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _Home_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _Home_vue_vue_type_template_id_5a90ec03___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _Home_vue_vue_type_template_id_5a90ec03___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/pages/Home.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/pages/Home.vue?");

/***/ }),

/***/ "./src/pages/Home.vue?vue&type=script&lang=js&":
/*!*****************************************************!*\
  !*** ./src/pages/Home.vue?vue&type=script&lang=js& ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_index_js_vue_loader_options_Home_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib??vue-loader-options!./Home.vue?vue&type=script&lang=js& */ \"./node_modules/vue-loader/lib/index.js?!./src/pages/Home.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_vue_loader_lib_index_js_vue_loader_options_Home_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/pages/Home.vue?");

/***/ }),

/***/ "./src/pages/Home.vue?vue&type=template&id=5a90ec03&":
/*!***********************************************************!*\
  !*** ./src/pages/Home.vue?vue&type=template&id=5a90ec03& ***!
  \***********************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Home_vue_vue_type_template_id_5a90ec03___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib??vue-loader-options!./Home.vue?vue&type=template&id=5a90ec03& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/pages/Home.vue?vue&type=template&id=5a90ec03&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Home_vue_vue_type_template_id_5a90ec03___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Home_vue_vue_type_template_id_5a90ec03___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/pages/Home.vue?");

/***/ }),

/***/ "./src/pages/taxIncluded.vue":
/*!***********************************!*\
  !*** ./src/pages/taxIncluded.vue ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _taxIncluded_vue_vue_type_template_id_a903919a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./taxIncluded.vue?vue&type=template&id=a903919a& */ \"./src/pages/taxIncluded.vue?vue&type=template&id=a903919a&\");\n/* harmony import */ var _taxIncluded_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./taxIncluded.vue?vue&type=script&lang=js& */ \"./src/pages/taxIncluded.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _taxIncluded_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _taxIncluded_vue_vue_type_template_id_a903919a___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _taxIncluded_vue_vue_type_template_id_a903919a___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/pages/taxIncluded.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack:///./src/pages/taxIncluded.vue?");

/***/ }),

/***/ "./src/pages/taxIncluded.vue?vue&type=script&lang=js&":
/*!************************************************************!*\
  !*** ./src/pages/taxIncluded.vue?vue&type=script&lang=js& ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_index_js_vue_loader_options_taxIncluded_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib??vue-loader-options!./taxIncluded.vue?vue&type=script&lang=js& */ \"./node_modules/vue-loader/lib/index.js?!./src/pages/taxIncluded.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_vue_loader_lib_index_js_vue_loader_options_taxIncluded_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack:///./src/pages/taxIncluded.vue?");

/***/ }),

/***/ "./src/pages/taxIncluded.vue?vue&type=template&id=a903919a&":
/*!******************************************************************!*\
  !*** ./src/pages/taxIncluded.vue?vue&type=template&id=a903919a& ***!
  \******************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_taxIncluded_vue_vue_type_template_id_a903919a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib??vue-loader-options!./taxIncluded.vue?vue&type=template&id=a903919a& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./src/pages/taxIncluded.vue?vue&type=template&id=a903919a&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_taxIncluded_vue_vue_type_template_id_a903919a___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_taxIncluded_vue_vue_type_template_id_a903919a___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n\n\n//# sourceURL=webpack:///./src/pages/taxIncluded.vue?");

/***/ }),

/***/ "./src/router/index.js":
/*!*****************************!*\
  !*** ./src/router/index.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n/* harmony import */ var vue_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue-router */ \"./node_modules/vue-router/dist/vue-router.esm.js\");\n/* harmony import */ var _pages_Home_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pages/Home.vue */ \"./src/pages/Home.vue\");\n/* harmony import */ var _pages_From_vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pages/From.vue */ \"./src/pages/From.vue\");\n/* harmony import */ var _pages_taxIncluded_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pages/taxIncluded.vue */ \"./src/pages/taxIncluded.vue\");\n\n\n\n\n\n\n\nvue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].use(vue_router__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n\nconst router = new vue_router__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n  routes: [\n    {\n      name: 'home',\n      path: '/',\n      component: _pages_Home_vue__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n    },\n    {\n      name: 'from',\n      path: '/from',\n      component: _pages_From_vue__WEBPACK_IMPORTED_MODULE_3__[\"default\"]\n    },\n    {\n      name: 'tax',\n      path: '/tax',\n      component: _pages_taxIncluded_vue__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n    }\n  ]\n})\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (router);\n\n\n//# sourceURL=webpack:///./src/router/index.js?");

/***/ })

/******/ });